from pymatgen.core.structure import Structure
from pymatgen.io.vasp.inputs import Incar, Kpoints

from core.data.vasp_infos import all_incar_keys
from core.dao.pymatgen.vasp import Potcar

import logging
import os

logger = logging.getLogger("futuremat.core.calculators.pymatgen.vasp")


class Vasp:
    """
    Reimplementing the futuremat VASP calculator with Pymatgen API.
    """

    def __init__(self, **kwargs):
        self.set_incar_params(**kwargs)

        try:
            self.use_gw = kwargs["use_gw"]
        except KeyError:
            self.use_gw = False

        try:
            self.kpoint_mode = kwargs["kpoint_mode"]
            assert self.kpoint_mode in (
                "monkhorst",
                "mp",
                "grid",
                "line",
                "band",
                "lines",
                "gamma",
            )
        except KeyError:
            raise KeyError("Please specify the kpoint_mode for the VASP calculation!")

        try:
            self.kppa = kwargs["kppa"]
        except KeyError:
            self.kppa = 2000  # default kppa for phonon calculations

        try:
            self.kppa_band = kwargs["kppa_band"]
        except KeyError:
            self.kppa_band = 20  # default kppa for band structure calculations

        try:
            self.gpu_run = kwargs["gpu_run"]
        except KeyError:
            self.gpu_run = False

    def set_incar_params(self, **kwargs):
        """
        From the provided keyword arguments, filter out those that belongs to the VASP INCAR keys.
        """
        self.incar_params = {}
        for key in kwargs.keys():
            if key.lower() in all_incar_keys:
                self.incar_params[key.lower()] = kwargs[key]

    def set_structure(self, structure: Structure):
        """
        Set the structure for the VASP calculation.

        :param structure: The structure to set, must be a pymatgen Structure oject
        :type structure: Structure or Crystal
        """
        self.structure = structure

    def _setup_kpoints(self):
        filename = "KPOINTS"
        if self.kpoint_mode in ("monkhorst", "mp", "grid"):
            kp = Kpoints.automatic_density(self.structure, kppa=self.kppa)

            kp.write_file(filename)
            logger.info(
                "Wrote Monkhorst-Pack KPOINTS (kppa=%s) to %s", self.kppa, filename
            )
        elif self.kpoint_mode in ("line", "band", "lines"):
            try:
                kp = Kpoints.automatic_linemode(self.kppa_band, self.structure)
                kp.write_file(filename)
                logger.info("Wrote band structure KPOINTS to %s", filename)
            except Exception:
                # fallback: try constructing a high-symmetry path and write a simple Line-mode KPOINTS
                from pymatgen.symmetry.bandstructure import HighSymmKpath

                kpath = HighSymmKpath(self.structure)
                # get_kpoints returns (kpoints_frac, labels) for a given line_density
                kpts, labels = kpath.get_kpoints(self.kppa_band)
                # Write a basic VASP line-mode KPOINTS file manually as fallback
                with open(filename, "w") as f:
                    f.write("Line-mode KPOINTS generated by pymatgen fallback\n")
                    f.write("{}\n".format(len(kpts)))
                    f.write("Line-mode\n")
                    f.write("Reciprocal\n")
                    for kp_frac, lab in zip(kpts, labels):
                        # kp_frac should be fractional coordinates (3-tuple)
                        if isinstance(kp_frac, (list, tuple)) and len(kp_frac) >= 3:
                            f.write(
                                "{:.8f} {:.8f} {:.8f}    ! {}\n".format(
                                    kp_frac[0], kp_frac[1], kp_frac[2], lab or ""
                                )
                            )
                        else:
                            # if element is (coord,label) style, try to unpack first element
                            try:
                                coord = kp_frac[0]
                                f.write(
                                    "{:.8f} {:.8f} {:.8f}    ! {}\n".format(
                                        coord[0], coord[1], coord[2], lab or ""
                                    )
                                )
                            except Exception:
                                continue
                logger.info("Wrote fallback line-mode KPOINTS to %s", filename)
        elif self.kpoint_mode == "gamma":
            kp = Kpoints.gamma_automatic(self.structure, kppa=self.kppa)
            kp.write_file(filename)
            logger.info(
                "Wrote Gamma-centered KPOINTS (kppa=%s) to %s", self.kppa, filename
            )
        else:
            logger.warning(
                "Unknown KPOINTS mode '%s' requested; no KPOINTS written.",
                self.kpoint_mode,
            )

    def _update_executable(self):
        """
        Update the VASP executable based on some user settings.
        """
        # TODO: expand this to more options as needed and make it generalised
        if not self.gpu_run:
            if self.kpoint_mode == "gamma":
                self.executable = "vasp_gam"
            else:
                self.executable = "vasp_std"
        else:
            if self.kpoint_mode == "gamma":
                self.executable = "vasp_gam-gpu"
            else:
                self.executable = "vasp_std-gpu"

        logger.info(
            "VASP calculation to be executed with the following binary: "
            + str(self.executable)
        )

    def setup(self):
        """
        This methods set up a VASP calculation for a given structure, including writing out the structure, POTCAR,
        INCAR and KPOINT files
        """
        logger.info("Setting up VASP calculation, write input file ...")

        self.structure.to(filename="POSCAR")
        logger.info("Successfully written the POSCAR file for structure optimisation.")

        incar = Incar(self.incar_params)
        incar.write_file("INCAR")

        if not self.gpu_run:
            # Append NCORE based on environment or detected CPU count so external
            # job scripts that rely on NCORE get a consistent INCAR entry.
            ncpus = os.environ.get("NCPUS")
            if not ncpus:
                # Fall back to Python's cpu count (may return None)
                ncpus = str(os.cpu_count() or 1)
            try:
                with open("INCAR", "a") as f:
                    f.write(f"NCORE={ncpus}\n")
                logger.info("Appended NCORE=%s to INCAR", ncpus)
            except Exception:
                logger.exception("Failed to append NCORE to INCAR")

            logger.info(
                "Successfully written the INCAR file for structure optimisation."
            )

        Potcar(self.structure).write(use_GW=self.use_gw)
        logger.info("Successfully written the POTCAR file for structure optimisation.")

        self._setup_kpoints()
        self._update_executable()

    def run(self):
        logger.info("Start executing VASP")

        # For the moment, implemented for running vasp on Katana HPC only, need to be generalised later

        if self.gpu_run:
            logger.info("Choose to run with GPU, automatically set mpirun -np $NGPUS")
            cmd = "mpirun -np $NGPUS " + self.executable
        else:
            logger.info("Choose to run with CPU, automatically set mpirun -np $CPUS")

            cmd = "mpirun -np $NCPUS" + self.executable

        exitcode = os.system("%s > %s" % (cmd, "vasp.log"))
        if exitcode != 0:
            raise RuntimeError("Vasp exited with exit code: %d.  " % exitcode)

    def execute(self):
        self.setup()
        # self.run()
