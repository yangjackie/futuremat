from pymatgen.core.structure import Structure
from pymatgen.io.vasp.inputs import Incar, Kpoints
from pymatgen.io.vasp.outputs import Vasprun


from core.dao.pymatgen.vasp import Potcar
from core.calculators.abstract_calculator import VaspBase

import logging
import os

logger = logging.getLogger("futuremat.core.calculators.pymatgen.vasp")


class Vasp(VaspBase):
    """
    Reimplementing the futuremat VASP calculator with Pymatgen API to set up and analyse the VASP calculations,
    where we provided our own hook to picked up some environmental settings from the HPC system to
    determine how these calculations are executed, which maybe changed if this is used by different users.
    """

    def __init__(self, force_rerun=False, directory=None, **kwargs):
        self.set_incar_params(**kwargs)

        try:
            self.use_gw = kwargs["use_gw"]
        except KeyError:
            self.use_gw = False

        try:
            self.kpoint_mode = kwargs["kpoint_mode"]
            assert self.kpoint_mode in (
                "monkhorst",
                "mp",
                "grid",
                "line",
                "band",
                "lines",
                "gamma",
            )
        except KeyError:
            raise KeyError("Please specify the kpoint_mode for the VASP calculation!")

        try:
            self.kppa = kwargs["kppa"]
        except KeyError:
            self.kppa = 2000  # default kppa for phonon calculations

        try:
            self.kppa_band = kwargs["kppa_band"]
        except KeyError:
            self.kppa_band = 20  # default kppa for band structure calculations

        try:
            self.gpu_run = kwargs["gpu_run"]
        except KeyError:
            self.gpu_run = False

        try:
            self.clean_after_success = kwargs["clean_after_success"]
        except KeyError:
            self.clean_after_success = False

        # a tag to determine if the calculation should be rerun if the previous calculation exists
        self.force_rerun = force_rerun

        # set up the directory to run the calculation
        self.directory = directory
        # self.__setup_directory()

    def __setup_directory(self):
        """
        Set up the directory to run the VASP calculation. Instead of let the higher order workflow handle the directory, we did it at the calculator level, just to make it become consistent with ASE VASP calculator behaviour.
        """
        self.cwd = os.getcwd()
        if self.directory is not None:
            if not os.path.exists(self.directory):
                os.mkdir(self.directory)

    @property
    def directory(self):
        return self._directory

    @directory.setter
    def directory(self, val):
        self._directory = val
        self.__setup_directory()

    def _setup_kpoints(self):
        filename = "KPOINTS"
        if self.kpoint_mode in ("monkhorst", "mp", "grid"):
            kp = Kpoints.automatic_density(self.structure, kppa=self.kppa)

            kp.write_file(filename)
            logger.info(
                "Wrote Monkhorst-Pack KPOINTS (kppa=%s) to %s", self.kppa, filename
            )
        elif self.kpoint_mode in ("line", "band", "lines"):
            try:
                kp = Kpoints.automatic_linemode(self.kppa_band, self.structure)
                kp.write_file(filename)
                logger.info("Wrote band structure KPOINTS to %s", filename)
            except Exception:
                # fallback: try constructing a high-symmetry path and write a simple Line-mode KPOINTS
                from pymatgen.symmetry.bandstructure import HighSymmKpath

                kpath = HighSymmKpath(self.structure)
                # get_kpoints returns (kpoints_frac, labels) for a given line_density
                kpts, labels = kpath.get_kpoints(self.kppa_band)
                # Write a basic VASP line-mode KPOINTS file manually as fallback
                with open(filename, "w") as f:
                    f.write("Line-mode KPOINTS generated by pymatgen fallback\n")
                    f.write("{}\n".format(len(kpts)))
                    f.write("Line-mode\n")
                    f.write("Reciprocal\n")
                    for kp_frac, lab in zip(kpts, labels):
                        # kp_frac should be fractional coordinates (3-tuple)
                        if isinstance(kp_frac, (list, tuple)) and len(kp_frac) >= 3:
                            f.write(
                                "{:.8f} {:.8f} {:.8f}    ! {}\n".format(
                                    kp_frac[0], kp_frac[1], kp_frac[2], lab or ""
                                )
                            )
                        else:
                            # if element is (coord,label) style, try to unpack first element
                            try:
                                coord = kp_frac[0]
                                f.write(
                                    "{:.8f} {:.8f} {:.8f}    ! {}\n".format(
                                        coord[0], coord[1], coord[2], lab or ""
                                    )
                                )
                            except Exception:
                                continue
                logger.info("Wrote fallback line-mode KPOINTS to %s", filename)
        elif self.kpoint_mode == "gamma":
            kp = Kpoints.gamma_automatic(self.structure, kppa=self.kppa)
            kp.write_file(filename)
            logger.info(
                "Wrote Gamma-centered KPOINTS (kppa=%s) to %s", self.kppa, filename
            )
        else:
            logger.warning(
                "Unknown KPOINTS mode '%s' requested; no KPOINTS written.",
                self.kpoint_mode,
            )

    def setup(self):
        """
        This methods set up a VASP calculation for a given structure, including writing out the structure, POTCAR,
        INCAR and KPOINT files
        """
        logger.info("Setting up VASP calculation, write input file ...")

        self.structure.to(filename="POSCAR")
        logger.info("Successfully written the POSCAR file for structure optimisation.")

        incar = Incar(self.incar_params)
        incar.write_file("INCAR")

        if not self.gpu_run:
            # Append NCORE based on environment or detected CPU count so external
            # job scripts that rely on NCORE get a consistent INCAR entry.

            ncpus = os.environ.get("NCPUS")
            logger.info("Auto-detect NCPUS from environment: %s", ncpus)

            if not ncpus:
                # Fall back to Python's cpu count (may return None)
                ncpus = str(os.cpu_count() or 1)
                logger.info(
                    "Auto-detect NCPUS failed, try from os.cpu_count(): %s; or set it to 1",
                    ncpus,
                )

            try:
                with open("INCAR", "a") as f:
                    f.write(f"NCORE={ncpus}\n")
                logger.info("Appended NCORE=%s to INCAR", ncpus)
            except Exception:
                logger.exception("Failed to append NCORE to INCAR")

        logger.info("Successfully written the INCAR file for structure optimisation.")

        Potcar(self.structure).write(use_GW=self.use_gw)
        logger.info("Successfully written the POTCAR file for structure optimisation.")

        self._setup_kpoints()

    def check_convergence(self):
        vasprun = Vasprun("vasprun.xml", parse_dos=False, parse_eigen=False)
        if vasprun.converged:
            logger.info("VASP calculation converged successfully.")
            self.completed = True
        else:
            logger.warning(
                "VASP calculation did not converge, please check cearefully!"
            )
            self.completed = False

    def tear_down(self):
        """
        Clean up the calculation folder after VASP finishes execution
        """
        logger.info("Clean up directory after VASP executed successfully.")
        files = [
            "CHG",
            "CHGCAR",
            "EIGENVAL",
            "IBZKPT",
            "PCDAT",
            "POTCAR",
            "WAVECAR",
            "LOCPOT",
            "node_info",
            "WAVECAR",
            "WAVEDER",
            "DOSCAR",
            "PROCAR",
            "REPORT",
        ]
        for f in files:
            try:
                os.remove(f)
            except OSError:
                pass

    def run_this(self) -> bool:
        if self.force_rerun is True:
            logger.info(
                "User asked the VASP calculations to be forced to rerun, will not check previous calculations, proceed to calculation..."
            )
            return True
        else:
            logger.info("Checking for existing calculations in the current folder...")
            _vasprun_file = os.path.join(os.getcwd(), "vasprun.xml")
            if os.path.exists(_vasprun_file):
                vasprun = Vasprun(
                    _vasprun_file,
                    parse_dos=False,
                    parse_eigen=False,
                )
                if vasprun.converged:
                    logger.info(
                        f"Previous VASP calculation in {_vasprun_file} is already converged. Skipping rerun."
                    )
                    return False
                else:
                    logger.info(
                        f"Previous VASP calculation in {_vasprun_file} did not converged. Will rerun this calculation."
                    )
                    return True
            else:
                logger.info(
                    "No previous VASP calculation found in the current folder. Proceed to calculation..."
                )
                return True

    def execute(self):
        os.chdir(self.directory)
        if self.run_this():
            self.setup()
            self.run()
            self.check_convergence()

            if self.completed and self.clean_after_success:
                self.tear_down()
        os.chdir(self.cwd)
